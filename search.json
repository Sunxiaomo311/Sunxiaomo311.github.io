[{"title":"【Java】JDK动态代理与CGLib动态代理","url":"/2021/01/05/【Java】JDK动态代理与CGLib动态代理/","content":"## 一、使用JDK动态代理\n\n基于 jdk 的动态代理需要借助于 **jdk 中 reflect 包下(java.lang.reflect.Proxy)的 Proxy** 以及 **(java.lang.reflect.InvocationHandler) InvacationHandler** 去生成代理对象。\n\n局限性是这种动态代理 **只适用于对有接口的类实现动态代理** \n\n原理其实是，**利用反射机制先生成要被代理对象的同级对象然后对这个同级对象进行增强** \n\n1、接口和实现类（代理对象）\n```\npublic interface UserDao {\n\tpublic void add();\n\tpublic void update();\n}\n```\n```\npackage cn.itcast.demo1;\n \npublic class UserDaoImp implements UserDao {\n \n\t@Override\n\tpublic void add() {\n\t\tSystem.out.println(\"this is add....\");\n \n\t}\n \n\t@Override\n\tpublic void update() {\n\t\tSystem.out.println(\"this is update....\");\n\t}\n \n}\n```\n2、动态代理（重点）\n```\npackage cn.itcast.demo1;\n \nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n/**\n * 使用jdk动态代理，增强方法\n * 想使用jdk动态代理，代理对象类必须实现至少一个接口 \n * @author Mr.Tong\n *\n */\n//继承InvocationHandler\npublic class JDKProxy implements InvocationHandler{\n\tprivate UserDao userDao;//想使用jdk动态代理，代理对象类必须实现至少一个接口\n \n\tpublic JDKProxy(UserDao userDao) {\n\t\tsuper();\n\t\tthis.userDao = userDao;\n\t}\n\tpublic UserDao createProxy(){\n\t\t//利用接口获得一个增强后的代理对象\n\t\tUserDao proxy = (UserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), this);\n\t\treturn proxy;\n\t}\n\t//调用对象的任何一个方法，都会执行该方法\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t if(\"add\".equals(method.getName())){\n\t\t\t System.out.println(\"这里是add方法的增强部分\");\n\t\t\t Object result = method.invoke(userDao, args);\n\t\t }\n\t\t if(\"update\".equals(method.getName())){\n\t\t\t System.out.println(\"这里是update方法的增强部分\");\n\t\t\t Object result = method.invoke(userDao, args);\n\t\t }\n\t\treturn null;\n\t}\n\t\n}\n```\n3、测试\n```\npackage cn.itcast.demo1;\n \nimport org.junit.Test;\n \npublic class Test1 {\n\t@Test\n\t//不使用动态代理\n\tpublic void demo1(){\n\t\t UserDao dao = new UserDaoImp();\n\t\t dao.add();\n\t\t dao.update();\n\t}\n\t@Test\n\tpublic void demo2(){\n\t\tUserDao userDao = new UserDaoImp();//实例化一个需要增强的对象\n\t\tUserDao daoProxy = new JDKProxy(userDao).createProxy();//jdk动态代理 返回一个增强之后的对象\n\t\tdaoProxy.add();\n\t}\n}\n```\n\n## 二、使用CGLib代理\n\nJDK动态代理是基于接口的方式，换句话来说就是代理类和目标类都实现同一个接口，那么代理类和目标类的方法名就一样了；\nCGLib动态代理是 **代理类去继承目标类，然后重写其中目标类的方法** ，这样也可以保证代理类拥有目标类的同名方法；\n\n1、代理对象\n```\npackage cn.itcast.demo2;\n \npublic class ProductDao {\n\tpublic void add(){\n\t\tSystem.out.println(\"this is add....\");\n\t}\n\tpublic void update(){\n\t\tSystem.out.println(\"this is update....\");\n\t}\n}\n```\n2、生成代理（重点）\n```\n\npackage cn.itcast.demo2;\n \nimport java.lang.reflect.Method;\n \nimport org.springframework.cglib.proxy.Callback;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodProxy;\n/**\n * CGLib生成代理的机制是继承\n * @author Mr.Tong\n *\n */\n//继承cglib的MethodInterceptor\npublic class CGLibProxy implements org.springframework.cglib.proxy.MethodInterceptor{\n\tprivate ProductDao productDao;\n \n\tpublic CGLibProxy(ProductDao productDao) {\n\t\tsuper();\n\t\tthis.productDao = productDao;\n\t}\n\tpublic ProductDao creatCGLibProxy(){\n\t\t//使用CGLib生成代理\n\t\t//1、创建核心类\n\t\tEnhancer enhancer = new Enhancer();\n\t\t//2、为它设置父类\n\t\tenhancer.setSuperclass(productDao.getClass());\n\t\t//3、设置回调\n\t\tenhancer.setCallback((Callback) this);\n\t\treturn (ProductDao) enhancer.create();\n\t}\n\t@Override\n\tpublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n\t\tif (\"add\".equals(method.getName())) {\n\t\t\tSystem.out.println(\"CGLib代理对象add方法的增强部分\");\n\t\t\tObject result = methodProxy.invokeSuper(proxy, args);\n\t\t\treturn result;\n\t\t}\n\t\treturn methodProxy.invokeSuper(proxy, args);\n\t}\n}\n```\n3、测试\n```\npackage cn.itcast.demo2;\n \nimport org.junit.Test;\n \npublic class Test2 {\n\t@Test\n\tpublic void demo1(){\n\t\t ProductDao productDao = new ProductDao();\n\t\tProductDao productDao2 = new CGLibProxy(productDao).creatCGLibProxy();\n\t\tproductDao2.add();\n\t}\n}\n```\n\n\n> 注意： Spring 的 AOP 的底层用到两种代理机制：\n > * JDK 的动态代理 :针对实现了接口的类产生代理.\n > * Cglib 的动态代理 :针对没有实现接口的类产生代理. 应用的是底层的字节码增强的技术 生成当前类的子类对象","categories":["编程","服务端"]},{"title":"【Java】1.8版本前后的区别","url":"/2020/12/25/【Java】1-8版本前后的区别/","content":"\n# java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包。 \n\n## _(在 java 6/7 / 8 时关于这个API 都是捆绑在一起的)_\n\n<Br>\n\n## Java版本号表示方法的不同来由\n\n_2004.9.30 发布了 J2SE 5.0。为什么这个版本命名和前面几个版本不一样呢？这个版本原本计划以 1.5 命名的，沿用以前的命名方式。但是为了更好的反映这个版本的成熟度，所以改名为 5.0。_\n\n_这个版本以后，有了一个新的版本控制系统，5.0 用来表示产品版本，用来表示稳定的 J2SE 版本，而 1.5.0 用来表示开发者版本，也就是 Java 5.0 = JDK 1.5.0。_\n\n_2006.12.11，J2SE 改名为 Java SE，版本号去掉了 .0。此后对应版本就是 Java 6 = JDK 1.6，Java 7 = JDK 1.7。_\n\n## Java8 版本新增主要特性\n##### 1. Lambda 和 函数式接口\n极大的减少代码量，代码看起来更清爽。\n函数式接口就是有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。可以隐式转化为 Lambda 表达式。\n\n##### 2. 方法引用\n通过方法引用，可以使用方法的名字来指向一个方法。使用一对冒号来引 \"::\" 用方法\n\n## Java9 版本新增主要特性\n\n##### 1. Jigsaw 模块系统\n在 Java 9 以前，打包和依赖都是基于 JAR 包进行的。JRE 中包含了 rt.jar，将近 63M，也就是说要运行一个简单的 Hello World，也需要依赖这么大的 jar 包。在 Java 9 中提出的模块化系统，对这点进行了改善。\n[关于模块化系统具体可以看看这篇文章](https://zhuanlan.zhihu.com/p/24800180)\n\n##### 2. JShell REPL\nJava 9 提供了交互式解释器。有了 JShell 以后，Java 终于可以像 Python，Node.js 一样在 Shell 中运行一些代码并直接得出结果了。\n\n\n## Java10 版本新增主要特性\n\n##### 1. 新增局部类型推断 var\n```\nvar a = \"aa\";  \nSystem.out.println(a);\n````\nvar 关键字目前只能用于局部变量以及 for 循环变量声明中。\n\n##### 2. 统一的垃圾回收接口，改进了 GC 和其他内务管理\n\n\n\n## Java11 版本新增主要特性\n\n##### 1. Lambda 中使用 var\n\n##### 2. java 直接编译并运行，省去先 javac 编译生成 class 再运行的步骤\n","tags":["Java"],"categories":["编程","服务端"]},{"title":"【Java编程思想】阅读笔记(3)--内部类","url":"/2020/10/14/【Java编程思想】阅读笔记-3-内部类/","content":"\n# 第十一章  内部类\n\n内部类是一种非常有用的特性，因为它允许把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。\n\n## 闭包与回调\n\n```\n闭包的概念：闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。\n```\n\n内部类是面向对象的闭包，它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。\n\n可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。\n\n```\n// innerclasses/Callbacks.java\n// Using inner classes for callbacks\n// {java innerclasses.Callbacks}\npackage innerclasses;\ninterface Incrementable {\n    void increment();\n}\n// Very simple to just implement the interface:\nclass Callee1 implements Incrementable {\n    private int i = 0;\n    @Override\n    public void increment() {\n        i++;\n        System.out.println(i);\n    }\n}\nclass MyIncrement {\n    public void increment() {\n        System.out.println(\"Other operation\");\n    }\n    static void f(MyIncrement mi) { mi.increment(); }\n}\n// If your class must implement increment() in\n// some other way, you must use an inner class:\nclass Callee2 extends MyIncrement {\n    private int i = 0;\n    @Override\n    public void increment() {\n        super.increment();\n        i++;\n        System.out.println(i);\n    }\n    private class Closure implements Incrementable {\n        @Override\n        public void increment() {\n            // Specify outer-class method, otherwise\n            // you'll get an infinite recursion:\n            Callee2.this.increment();\n        }\n    }\n    Incrementable getCallbackReference() {\n        return new Closure();\n    }\n}\nclass Caller {\n    private Incrementable callbackReference;\n    Caller(Incrementable cbh) {\n        callbackReference = cbh;\n    }\n    void go() { callbackReference.increment(); }\n}\npublic class Callbacks {\n    public static void main(String[] args) {\n        Callee1 c1 = new Callee1();\n        Callee2 c2 = new Callee2();\n        MyIncrement.f(c2);\n        Caller caller1 = new Caller(c1);\n        Caller caller2 =\n                new Caller(c2.getCallbackReference());\n        caller1.go();\n        caller1.go();\n        caller2.go();\n        caller2.go();\n    }\n}\n```\n\n输出：\n\n```\nOther operation\n1\n1\n2\nOther operation\n2\nOther operation\n3\n```\n\n就代码而言，Callee1 是更简单的解决方式。Callee2 继承自 MyIncrement，后者已经有了一个不同的 increment() 方法，并且与 Incrementable 接口期望的 increment() 方法完全不相关。所以如果 Callee2 继承了 MyIncrement，就不能为了 Incrementable 的用途而覆盖 increment() 方法，于是只能使用内部类独立地实现 Incrementable。\n\n内部类 Closure 实现了 Incrementable，以提供一个返回 Callee2 的 **“钩子”（hook）** -而且是一个安全的钩子。无论谁获得此 Incrementable 的引用，都只能调用 increment()，除此之外没有其他功能。\n\n**回调的价值在于它的灵活性：可以在运行时动态地决定需要调用什么方法。**\n\n## 内部类与控制框架\n\n应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。\n\n控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。\n\n框架实现选择内部类（比如经典框架：GreenhouseControls），原因：\n\n1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的 action()。\n2. 内部类能够很容易地访问外部类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。\n\n## 内部类标识符\n\n由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个\"meta-class\"，叫做 Class 对象）。\n\n内部类也必须生成一个 **.class** 文件以包含它们的 Class 对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“ **$\"，再加上内部类的名字。例如，LocalInnerClass.java** 生成的 .class 文件包括：\n\n```\nCounter.class\nLocalInnerClass$1.class\nLocalInnerClass$LocalCounter.class\nLocalInnerClass.class\n```\n\n如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“ **$** ”的后面。\n\n虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是 java 的标准命名方式，所以产生的文件自动都是平台无关的。（注意，为了保证你的内部类能起作用，Java 编译器会尽可能地转换它们。）","tags":["Java"],"categories":["编程","服务端"]},{"title":"【Java编程思想】阅读笔记(2)--“万物皆对象”的解读与细节","url":"/2020/08/28/【Java编程思想】阅读笔记-2-“万物皆对象”的解读与细节/","content":"\n# 第三章  万物皆对象\n\nJava 是一种更纯粹的面向对象编程语言。Java 语言假设你只进行面向对象编程。\n\n## 对象操纵\n\nJava 利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用” 。\n\n## 数据存储\n\n有5个不同的地方可以存储数据：\n\n1. **寄存器（Registers）**最快的存储区域，位于 CPU 内部。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。\n\n2. **栈内存（Stack）**存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。\n\n3. **堆内存（Heap）**这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。\n\n4. **常量存储（Constant storage）**常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中。\n\n5. **非 RAM 存储（Non-RAM storage）**数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。\n\n## 基本类型\n\nJava 的基本类型的创建并不是通过 new 关键字来产生。**通常 new 出来的对象都是保存在堆内存中的**。\n\n对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 new 创建变量，而是使用一个“自动”变量。 这个变量直接存储\"值\"，并置于栈内存中，因此更加高效。\n\nJava 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。**这种不变性也是 Java 更具可移植性的一个原因**。\n\n\n|基本类型|大小|最小值|最大值|包装类型|\n|:-:|:-:|:-:|:-:|:-:|\n|boolean|—|—|—|Boolean|\n|char|16 bits|Unicode 0|Unicode 2^16 -1|Character\n|byte|8 bits|-128|+127|Byte|\n|short|16 bits|- 2^15|+ 2^15 -1|Short|\n|int|32 bits|- 2^31|+ 2^31 -1|Integer|\n|long|64 bits|- 2^63|+ 2^63 -1|Long|\n|float|32 bits|IEEE754|IEEE754|Float|\n|double|64 bits|IEEE754|IEEE754|Double|\n|void|—|—|—|Void|\n\n所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值 “true” 或 “false” 。基本类型有自己对应的包装类型，如果希望在堆内存里表示基本类型的数据，就需要用到它们的包装类.\n\n## 数组的存储\n\nJava 的设计主要目标之一是安全性。在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且 Java 经常可以优化这些操作。\n\n当创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为null。在使用该数组之前，必须为每个引用指定一个对象。还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。\n\n## 对象清理\n\n### 对象作用域\n\n```\n{\n    String s = new String(\"a string\");\n} \n// 作用域终点\n```\n\n引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。\n\nJava 的垃圾收集器会检查所有 new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。\n\n## 类的创建\n\n### 基本数据类型默认值\n\n对象的字段在初始化时会被赋予默认值。方法内的变量则不会，如果不进行赋值操作将无法通过编译。\n\n### 方法使用\n\n在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。\n\n**方法名和参数列表统称为方法签名（signature of the method）。签名作为方法的唯一标识。**\n\n调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。\n\n## 程序编写\n\n### 命名可见性\n\nJava 创建者希望我们反向使用自己的网络域名，为一个类库生成一个明确的名称。\n\n空目录填充了深层次结构，它们不仅用于表示反向 URL，还用于捕获其他信息。这些长路径基本上用于存储有关目录中的内容的数据。\n\n### static关键字\n\n类是对象的外观及行为方式的描述。通常只有在使用 new 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。\n\n当 static 关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。\n\n## 编码风格\n\nJava 编程语言编码规范（Code Conventions for the Java Programming Language） 要求类名的首字母大写。 如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）例如：\n\n```\nclass AllTheColorsOfTheRainbow {\n    // ...\n}\n```\n\n有时称这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母不需要大写。代码示例：\n\n```\nclass AllTheColorsOfTheRainbow {\n    int anIntegerRepresentingColors;\n    void changeTheHueOfTheColor(int newHue) {\n        // ...\n    }\n    // ...\n}\n```\n\n在 Oracle 的官方类库中，花括号的位置同样遵循和本书中上述示例相同的规范。","tags":["Java"],"categories":["编程","服务端"]},{"title":"【Java编程思想】阅读笔记(1)--新的认知与回顾OOP思想","url":"/2020/08/24/【Java编程思想】阅读笔记-1-新的认知与回顾OOP思想/","content":"***前言：***\n*&nbsp;&nbsp;&nbsp;&nbsp;从用Java书写第一个Hello World程序到现在，已经过去两年半了。在这两年半的时间里，我从最开始系统地了解Java编程，用自己的思维方式套用并理解其中需要消化的锚点知识；到盲目学用其他语言与新技术，用自身思维固化后形成的坚硬外壳去鲁莽撞破一道道技能关卡；最后走入职场，在不断重复的、低级的cv工作中让这层壳越裹越厚，逐渐摸不清方向。\n&nbsp;&nbsp;&nbsp;&nbsp;夜里坐在窗边的办公桌上，放松下来的大脑逐渐回顾过往。才发现在编程技术的道路上，自己追求的过于浮夸了。朝不同方向不断出发又不断折回，到最后还是停留在了原地。\n&nbsp;&nbsp;&nbsp;&nbsp;好好梳理了一下方向，最终决定折回起点，重新系统化钻研Java这门技术。不同的是，现在的我有了弯路上行进的宝贵经验，以及万丈高楼平地起的坚定决心。*\n\n----\n<br/>\n\n# 第一章  对象的概念\n\n## 启\n\n> “我们没有意识到惯用语言的结构有多大的力量。可以毫不夸张地说，它通过语义反应机制奴役我们。语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界。” -- Alfred Korzybski (1930)\n\n作者第一章开头引用的话，毫不夸张。正如语言的差异，造就了不同地区人群文化与性格上的差异。英文语法严谨，欧美人考虑问题就偏线性化，在意因果关系；而汉语的语法相对松散，没有特别固定的口语说法，才造就了国人圆融的处世原则。\n\n所以，不同的编程语言，同样也会对使用者的思维方式乃至最终编写出的程序产生影响。编程语言就是创建应用程序的思想结构。\n\n**Object-Oriented Programming，即OOP，面向对象编程。是一种编程思维方式和编码架构。**\n\n## 抽象\n\n程序员需要在机器模型（“解决方式空间”）和实际解决的问题模型（“问题空间”）之间建立起一种关联。\n\n汇编语言是对底层机器的轻微抽象。接着出现的“命令式”语言（如 FORTRAN，BASIC 和 C）是对汇编语言的抽象。这些偏底层抽象的语言要求我们着重考虑计算机的结构，而非问题本身的结构。\n\n面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。将问题空间中的元素以及它们在解决方案空间的表示称作“对象”（Object）。当然，还有一些在问题空间没有对应的对象体。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。所以当你在阅读描述解决方案的代码时，也是在阅读问题的表述。\n\n总之，OOP 允许我们**根据问题来描述问题（着重于对解决问题的描述建模）**，而不是根据运行解决方案的计算机。\n\nSmalltalk 作为第一个成功的面向对象并影响了 Java 的程序设计语言 ，其五大基本特征如下。（通过这些特征，我们可理解“纯粹”的面向对象程序设计方法是什么样的）：\n\n1. **万物皆对象**（将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作）\n2. **程序是一组对象，通过消息传递来告知彼此该做什么**\n3. **每个对象都有自己的存储空间，可容纳其他对象**（通过封装现有对象，可制作出新型对象）\n4. **每个对象都有一种类型**（一个类最重要的特征就是“能将什么消息发给它？”）\n5. **同一类所有对象都能接收相同的消息**（这一特性称为对象的“可替换性”，是OOP最重要的概念之一）\n\n## 接口\n\n在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”。创建好一个类后，可根据情况生成许多对象。随后，可将那些对象作为要解决问题中存在的元素进行处理。如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系，是主要的问题。\n\n**我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。**“类型”与“接口”的对应关系是面向对象程序设计的基础。\n\n## 服务提供\n\n在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。你的程序本身将为用户提供服务，并且它能通过调用其他对象提供的服务来实现这一点。我们的最终目标是开发或调用工具库中已有的一些对象，提供理想的服务来解决问题。开发前我们可以将实际问题一一分解，抽象成一组服务。\n\n**软件设计的基本原则是高内聚：每个组件的内部作用明确，功能紧密相关。每个对象都提供了一组紧密的服务。**\n\n在良好的面向对象设计中，每个对象功能单一且高效。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。\n\n## 封装\n\n编程的侧重领域划可以分为研发领域和应用领域。应用程序员调用研发程序员构建的基础工具类来做快速开发，研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。\n\n访问控制可以使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。\n\nJava 有三个显式关键字和一个隐式默认关键字来设置类中的访问权限：\n\n1. public（公开）表示任何人都可以访问和使用该元素；\n2. private（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；\n3. protected（受保护）类似于 private，区别是子类（下一节就会引入继承的概念）可以访问 protected 的成员，但不能访问 private 成员；\n4. default（默认）如果你不使用前面的三者，默认就是 default 访问权限。default 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。\n\n## 继承\n\n通过使用对象，类型层次结构成为了主要模型，因此你可以直接从真实世界中对系统的描述过渡到用代码对系统进行描述。\n\n代码和设计方案的复用性是面向对象程序设计的优点之一。\n从现有类型继承创建新类型。这种新类型不仅包含现有类型的所有成员（尽管私有成员被隐藏起来并且不可访问），而且更重要的是它复制了基类的接口。也就是说，**基类对象接收的所有消息也能被派生类对象接收**。根据类接收的消息，我们知道类的类型。\n\n### 单继承结构\n\n在 Java 中，最终基类的名字是 Object。\n\n单继承的结构使得垃圾收集器的实现更为容易。这也是 Java 在 C++ 基础上的根本改进之一。\n\n由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤其重要，例如异常处理。同时，这也让我们的编程具有更大的灵活性。\n\n## 多肽\n\n以基类为蓝本派生新类型是扩展面向对象程序以处理新情况的，封装变化的基本方法之一。 例如，你可以通过通用的“形状”基类派生出新的“五角形”形状的子类，而不需要修改通用\"形状\"基类的方法。\n\n在传统意义上，编译器不能进行函数调用。由非 OOP 编译器产生的函数调用会引起所谓的**早期绑定**，这意味着编译器生成对特定函数名的调用，该调用会被解析为将执行的代码的**绝对地址**。\n\n通过继承，程序直到运行时才能确定代码的地址，因此发送消息给对象时，还需要其他一些方案。为了解决这个问题，面向对象语言使用**后期绑定**的概念。当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。\n\n把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。在面向对象的编程里，经常利用这种方法来给程序解耦。\n\n发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址（此过程在多态性章节中有详细介绍）。因此，每个对象的行为根据特定代码位的内容而不同。\n\n在 Java 中，编译器和运行时系统会负责对所有细节的控制，动态绑定是默认行为，不需要额外的关键字来实现多态性（C++ 使用 virtual 关键字）。\n\n## 集合\n\n创建一个新类型的对象来引用、容纳其他的对象，在 Java 中可以使用“集合”（Collection）。（也可称之为“容器”，但“集合”这个称呼更通用。）\n\n“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，开发者不用关心过程是如何实现的。\n\n我们可以一开始使用 LinkedList 构建程序，在优化系统性能时改用 ArrayList。通过对 List 接口的抽象，我们可以很容易地将 LinkedList 改为 ArrayList。\n\n在 Java 5 泛型出来之前，集合中保存的是通用类型 Object。Java 5 版本支持了参数化类型机制，称之为“泛型”（Generic）。泛型是 Java 5 的主要特性之一。\n\n## 对象的生命周期\n\n在 C++ 程序设计中，当使用完一个对象后，必须明确将其删除。 在 C++ 设计中采用的观点是效率第一，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。\n\nJava 使用动态内存分配。每次创建对象时，使用 new 关键字构建该对象的动态实例。在堆内存（Heap）中动态地创建对象，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。Java 的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。\n\n## 异常处理机制\n\nJava 从一开始就内置了异常处理，这是 Java 语言唯一接受的错误报告方法。如果没有编写适当的异常处理代码，运行时出现错误将会收到一条编译时错误消息。\n\n异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。“异常机制”提供了一种可靠地从错误状况中恢复的方法，使得我们可以编写出更健壮的程序。\n\n## 小结\n\n设计良好的 Java 程序代码更容易被人阅读理解。由于 Java 类库的复用性，通常程序要写的代码也会少得多。 ","tags":["Java"],"categories":["编程","服务端"]},{"title":"【hexo插件】利用hexo-calendar实现仿GitHub的活动日历功能","url":"/2020/08/11/【hexo插件】利用hexo-calendar实现仿GitHub的活动日历功能/","content":"\n![](7.png)\n\n>在个人网站首页添加类似github中的活动日历功能，实现步骤如下:\n\n<br/>\n\n### 1. 在博客根目录引入[hexo-calendar](https://github.com/HCLonely/hexo-calendar/blob/master/README_CN.md)插件\n\n```\nnpm i hexo-calendar -S\n```\n\n*注意：引入前请注意插件作者给出的前提条件：*\n![](10.png)\n\n<br/>\n\n### 2. 在首页文章md文件中添加如下标签代码：\n\n```\n{% calendar %}\n{\"monthLang\": \"cn\", \"dayLang\": \"cn\", \"title\": \"活动日历\"}\n{% endcalendar %}\n```\n<br/>\n\n### 3. 启动hexo服务，在本地查看效果\n\n```\nhexo clean && hexo s\n```\n访问网页后，发现活动日历已经能正常显示了\n\n![](3.png)\n但以强迫症的眼光看，这个显示效果有点不尽人意。\n1. 只显示了十个月的数据。这个看了作者给出的插件文档，默认是显示40周的数据，需要更改标签中的weeks属性。\n2. \b有活跃度的日期单元格颜色与主题不搭配，希望改成自定的颜色。\n\n所以接着修改细节问题：\n\n<br/>\n\n### 4. 更改标签中的属性值\n根据文档提示：\n\n![](8.png)\n\n修改标签weeks属性为一年52周（注意：严格遵守json语法格式）：\n```\n{\"monthLang\": \"cn\", \"dayLang\": \"cn\", \"title\": \"活动日历\"，\"weeks\":52}\n```\n\n修改完成后又发现一个问题，增加了两个月的单元格后，插件大小显示的有问题，还需要更改宽度。\n\n![](4.png)\n\n宽度使用width属性更改。实际上宽度修改到足够包裹插件单元格后，又可能会被外层div遮挡。所以最后决定通过用更改每个单元格大小的方式来使插件总体积缩小，完整显示一年的活跃度：\n\n1. 打开博客根目录下的node_modules/hexo-calender/index.js文件。\n2. 找到  `cellSize: [13, 13]` 一行,更改为`cellSize: [11, 11]`。\n![](6.png)\n3. 更改标签代码宽高属性。\n```\n{\"width\":\"640\", \"height\":\"140\", \"weeks\":52, \"monthLang\": \"cn\", \"dayLang\": \"cn\", \"title\": \"活动日历\"}\n```\n\n<br/>\n\n### 5. 更改活动单元格颜色\n\n同样也是打开博客根目录下的node_modules/hexo-calender/index.js文件，更改`color: [\"#ebedf0\", \"#c6e48b\", \"#7bc96f\", \"#239a3b\", \"#196127\"]`一行中的后四个颜色值。\n\n我的网站主题色是蓝色系，所以用f12打开网页开发者工具，用取色器获取背景图片中不同层次的蓝色。\n![](1.png)\n\n全部修改完成后，刷新重启服务，显示效果如下：\n![](2.png)\n\n**完美 😂**\n\n<br/>\n\n### 6. 上传部署在GitHub的博客网站\n\n有两点需要注意的，作者已经给出提示了：\n\n>注意：此插件会和hexo g命令冲突，请使用hexo ge或hexo generate替代hexo g命令！\n\n以及\n\n>如果你使用了Travis CI, Github Action之类的自动部署，那么你需要在推送源码之前使用hexo gc -w=40命令生成一个calendar.json文件。-w=40代表显示 40 周之前至今的活动记录。\n\n我改动了weeks的值为52，所以最后推送更新的指令是：\n\n```\nhexo gc -w=52\n\nhexo generate -d\n```\n","tags":["hexo插件"],"categories":["编程","前端"]},{"title":"奇异人生游戏截图","url":"/2020/08/07/奇异人生游戏截图/","content":"\n#### 《奇异人生(Life is Strange)》游戏截图（部分误解向）\n\n![](5.jpeg)\n\n![](1.jpeg)\n\n![](4.jpeg)\n\n![](3.jpeg)\n\n![](2.jpeg)\n\n![](6.jpeg)\n\n![](7.jpeg)\n\n![](8.jpeg)\n\n![](9.jpeg)\n\n![](10.jpeg)\n\n![](11.jpeg)\n\n![](12.jpeg)","tags":["游戏截图"],"categories":["生活","游戏"]},{"title":"生活-游戏（分类页）","url":"/2020/08/07/生活-游戏（分类页）/","categories":["生活","游戏"]},{"title":"摄影-胶片（分类页）","url":"/2020/08/07/摄影-胶片（分类页）/","categories":["摄影","胶片"]},{"title":"编程-人工智能（分类页）","url":"/2020/08/07/编程-人工智能（分类页）/","categories":["编程","人工智能"]},{"title":"编程-服务端（分类页）","url":"/2020/08/07/编程-服务端（分类页）/","categories":["编程","服务端"]},{"title":"编程-前端（分类页）","url":"/2020/08/07/编程-前端（分类页）/","categories":["编程","前端"]},{"title":"生活-中医学（分类页）","url":"/2020/08/07/生活-中医学（分类页）/","categories":["生活","中医学"]},{"title":"生活-烹饪（分类页）","url":"/2020/08/07/生活-烹饪（分类页）/","categories":["生活","烹饪"]},{"title":"与君初相识 犹如故人归","url":"/2020/08/03/hello-world/","content":"#### 欢迎来到『 扶桑界 』，本站不定期更新个人博客与相册内容。\n\n{% calendar %}\n{\"width\":\"640\", \"height\":\"140\", \"weeks\":52, \"monthLang\": \"cn\", \"dayLang\": \"cn\", \"title\": \"活动日历\"}\n{% endcalendar %}\n\n### 进站须知：\n- 右上角与分类页面提供内容检索，🏷️  标签页面提供关键词检索\n- 相册页面为个人摄影集，浏览时请遵循相关知识共享许可协议\n- 本站由[Hexo](https://hexo.io/)框架作为引擎，页面采用[stun](https://github.com/liuyib/hexo-theme-stun)主题。相关内容点击链接查看\n\n>如提供外部链接失效、文章内有错误、版权问题等，请留言或通过QQ联系我","tags":["杂项"]}]